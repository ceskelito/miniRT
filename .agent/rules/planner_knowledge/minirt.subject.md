# miniRT: My First RayTracer with MiniLibX

**Summary:** This project introduces Raytracing, enabling you to render simple computer-generated images and implement mathematical formulas.

**Version:** 9.0

## Contents

I. [Introduction](#i-introduction)
II. [Common Instructions](#ii-common-instructions)
III. [AI Instructions](#iii-ai-instructions)
IV. [Mandatory part - miniRT](#iv-mandatory-part---minirt)
V. [Bonus part](#v-bonus-part)
VI. [Examples](#vi-examples)
VII. [Submission and peer-evaluation](#vii-submission-and-peer-evaluation)

## I Introduction

When rendering three-dimensional computer-generated images, there are two approaches: “Rasterization” and “Ray Tracing.” Ray Tracing, developed in 1968, produces a higher degree of visual realism but is computationally expensive.

Figure I.1: The pictures above are rendered with the ray tracing technique.

miniRT is your first ray tracer coded in C, normed, humble, but functional. The goal is to implement mathematical or physical formulas without being a mathematician.

## II Common Instructions

*   Your project must be written in C.
*   Your project must be written in accordance with the Norm. Bonus files/functions are included in the norm check.
*   Your functions should not quit unexpectedly (segmentation fault, bus error, double free, etc.) except for undefined behavior.
*   All heap-allocated memory must be properly freed when necessary. Memory leaks will not be tolerated.
*   Submit a Makefile that compiles your source files with the flags `-Wall`, `-Wextra`, and `-Werror`, using `cc`.
*   Your Makefile must contain at least the rules `$(NAME)`, `all`, `clean`, `fclean` and `re`.
*   To submit bonuses, include a `bonus` rule in your Makefile. Bonuses must be placed in `_bonus.{c/h}` files.
*   If using your `libft`, copy its sources and Makefile into a `libft` folder. Your project’s Makefile must compile the library.
*   Create test programs for your project.
*   Submit your work to the assigned Git repository.
*   Deepthought grading will occur after peer-evaluations.

## III AI Instructions

*   **Context:** Use AI to assist with tasks, but approach it with caution and critically assess the results.
*   **Main message:**
    *   Use AI to reduce repetitive or tedious tasks.
    *   Develop prompting skills.
    *   Learn how AI systems work.
    *   Continue building both technical and power skills by working with your peers.
    *   Only use AI-generated content that you fully understand and can take responsibility for.
*   **Learner rules:**
    *   Explore AI tools and understand how they work.
    *   Reflect on your problem before prompting.
    *   Systematically check, review, question, and test anything generated by AI.
    *   Always seek peer review.
*   **Phase outcomes:**
    *   Develop prompting skills.
    *   Boost your productivity with effective use of AI tools.
    *   Continue strengthening computational thinking, problem-solving, adaptability, and collaboration.
*   **Comments and examples:**
    *   Be prepared to demonstrate real understanding.
    *   Make peer learning a priority.
    *   Rely on peers as a quality checkpoint.

    *Good practice:* I ask AI: “How do I test a sorting function?” It gives me a few ideas. I try them out and review the results with a peer. We refine the approach together.

    *Bad practice:* I ask AI to write a whole function, copy-paste it into my project. During peer- evaluation, I can’t explain what it does or why. I lose credibility — and I fail my project.

## IV Mandatory part - miniRT

*   **Program name:** miniRT
*   **Turn in files:** All your files
*   **Makefile:** all, clean, fclean, re, bonus
*   **Arguments:** a scene in format \*.rt
*   **External functs.:**
    *   open, close, read, write, printf, malloc, free, perror, strerror, exit.
    *   All functions of the math library. (Man page: man math.h or man 3 math. Don’t forget to compile with the -lm flag).
    *   All functions of the MinilibX library.
    *   gettimeofday()
*   **Libft authorized:** Yes
*   **Description:** Generate images using the Raytracing protocol.

**Constraints:**

*   Use the miniLibX library.
*   The management of your window must remain fluid.
*   You need at least these three simple geometric objects: plane, sphere, cylinder.
*   All possible intersections and the insides of the objects must be handled correctly.
*   Your program must be able to resize the unique properties of objects: diameter for a sphere and the width and height for a cylinder.
*   Your program must be able to apply translation and rotation transformations to objects, lights, and cameras (except for spheres and lights that cannot be rotated).
*   Light management: spot brightness, hard shadows, ambient lighting (objects are never completely in the dark). You must implement ambient and diffuse lighting.
*   The program displays the image in a window and respects the following rules:
    *   Pressing ESC must close the window and quit the program cleanly.
    *   Clicking on the red cross on the window frame must close the window and quit the program cleanly.
    *   The use of images from the minilibX library is strongly recommended.
*   Your program must take as its first argument a scene description file with the .rt extension.
    *   Each type of element can be separated by one or more line breaks.
    *   Each type of information from an element can be separated by one or more spaces.
    *   Each type of element can be set in any order in the file.
    *   Elements defined by a capital letter can only be declared once in the scene.
    *   The first piece of information for each element is the type identifier, followed by all specific information for each object in a strict order.

**Scene Description Elements:**

*   **Ambient lighting:** `A 0.2 255,255,255`
    *   identifier: `A`
    *   ambient lighting ratio in the range \[0.0,1.0]: `0.2`
    *   R, G, B colors in the range \[0-255]: `255, 255, 255`
*   **Camera:** `C -50.0,0,20 0,0,1 70`
    *   identifier: `C`
    *   x, y, z coordinates of the viewpoint: `-50.0,0,20`
    *   3D normalized orientation vector, in the range \[-1,1] for each x, y, z axis: `0.0,0.0,1.0`
    *   FOV: Horizontal field of view in degrees in the range \[0,180]: `70`
*   **Light:** `L -40.0,50.0,0.0 0.6 10,0,255`
    *   identifier: `L`
    *   x, y, z coordinates of the light point: `-40.0,50.0,0.0`
    *   the light brightness ratio in the range \[0.0,1.0]: `0.6`
    *   (unused in mandatory part) R, G, B colors in the range \[0-255]: `10, 0, 255`
*   **Sphere:** `sp 0.0,0.0,20.6 12.6 10,0,255`
    *   identifier: `sp`
    *   x, y, z coordinates of the sphere center: `0.0,0.0,20.6`
    *   the sphere diameter: `12.6`
    *   R,G,B colors in the range \[0-255]: `10, 0, 255`
*   **Plane:** `pl 0.0,0.0,-10.0 0.0,1.0,0.0 0,0,225`
    *   identifier: `pl`
    *   x, y, z coordinates of a point in the plane: `0.0,0.0,-10.0`
    *   3D normalized normal vector, in the range \[-1,1] for each x, y, z axis: `0.0,1.0,0.0`
    *   R,G,B colors in the range \[0-255]: `0,0,225`
*   **Cylinder:** `cy 50.0,0.0,20.6 0.0,0.0,1.0 14.2 21.42 10,0,255`
    *   identifier: `cy`
    *   x, y, z coordinates of the center of the cylinder: `50.0,0.0,20.6`
    *   3D normalized vector of axis of cylinder, in the range \[-1,1] for each x, y, z axis: `0.0,0.0,1.0`
    *   the cylinder diameter: `14.2`
    *   the cylinder height: `21.42`
    *   R, G, B colors in the range \[0,255]: `10, 0, 255`

**Example .rt scene:**

```
A 0.2 255,255,255
C -50,0,20 0,0,1 70
L -40,0,30 0.7 255,255,255
pl 0,0,0 0,1.0,0 255,0,225
sp 0,0,20 20 255,0,0
cy 50.0,0.0,20.6 0,0,1.0 14.2 21.42 10,0,255
```

*   If any misconfiguration is encountered in the file, the program must exit properly and return `"Error\n"` followed by an explicit error message.
*   For the defense, have a whole set of scenes focused on what is functional.

## V Bonus part

The Ray-Tracing technique could handle many more things like reflection, transparency, refraction, more complex objects, soft shadows, caustics, global illumination, bump mapping, .obj file rendering, etc.

Figure V.1: A spot, a space skybox, and a shiny earth-textured sphere with bump- mapping

Bonuses will be evaluated only if your mandatory part is perfect.

**Bonus list:**

*   Add specular reflection to achieve a full Phong reflection model.
*   Color disruption: checkerboard pattern.
*   Colored and multi-spot lights.
*   One other second-degree object: cone, hyperboloid, paraboloid..
*   Handle bump map textures.

You are allowed to use other functions and add features to your scene description to complete the bonus part.

## VI Examples

Figure VI.1: A sphere, one spot, some shine (optional).

Figure VI.2: A cylinder, one spot.

Figure VI.3: A cone (optional), a plane, one spot.

Figure VI.4: A bit of everything, including 2 planes.

Figure VI.5: Same scene different camera.

Figure VI.6: This time with shadows.

Figure VI.7: With multiple spots.

Figure VI.8: And finally, with multiple spots and a shiny checkered (optional) sphere in the middle.

## VII Submission and peer-evaluation

Submit your assignment in your Git repository.

During the evaluation, a brief modification of the project may occasionally be requested.

